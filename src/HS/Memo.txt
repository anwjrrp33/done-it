[ch01. 시간복잡도]

20페이지
왜 1,000,000log(1,000,000) = 6,000,000이 아닌지??

시간복잡도는 가장 많이 중첩된 반복문을 기준으로 도출한다.



[ch02. 디버깅]



[ch03. 자료구조]

03-1. 배열과 리스트

* 배열
 - 메모리의 연속 공간에 값이 채워져 있는 형태의 자료구조.
 - 인덱스를 통해 참조할 수 있음.
 - 선언한 자료형의 값만 저장할 수 있음.

* 배열의 특징
1) 인덱스를 사용하여 값에 바로 접근 가능
2) 새로운 값을 삽입하거나 특정 인덱스의 값을 삭제하기 어려움.
   값을 삽입하거나 삭제하려면 해당 인덱스 주변에 있는 값을
   이동시키는 과정이 필요함.
3) 크기는 선언할 때 지정가능하며, 한번 선언하면 바꿀 수 없음.

* 리스트
 - 값과 포인터를 묶은 노드라는 것을 포인터로 연결한 자료구조

* 리스트의 특징
1) 인덱스가 없으므로 값에 접근하려면 Head 포인터부터 순서대로 접근해야 함.
   값에 접근하는 속도가 느림.
2) 포인터로 연결되어 있으므로 데이터를 삽입/삭제하는 연산 속도가 빠름
3) 선언할 때 크기를 별도로 지정하지 않아도 됨.
   리스트 크기는 정해져있지 않고, 크기가 변하기 쉬운 데이터를 다룰 때 적절.
4) 포인터를 저장할 공간이 필요하므로 배열보다 구조가 복잡함.


03-5. 스택과 큐

* 스택과 큐 : 배열에서 발전된 형태의 자료구조임.
스택과 큐는 구조는 비슷하나 처리 방식은 다르다.

* 스택
 - 삽입과 삭제 연산이 후입선출로 이뤄지는 자료구조
 - 후입선출은 삽입과 삭제가 한 쪽에서만 일어나는 특징
 - 용어
  위치
   - top: 삽입과 삭제가 일어나는 위치
  연산
   - push: top 위치에 새로운 데이터를 삽입하는 연산
   - pop: top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
   - peek: top 위치에 현재 있는 데이터를 단순 확인하는 연산
 - 깊이 우선 탐색(DFS), 백트래킹 종류의 코딩테스트에 효과적. 반드시 알아야함
 - 후입선출은 개념자체가 재귀 함수 알고리즘 원리와 일맥상통함

* 큐
 - 삽인과 삭제 연산이 선입선출로 이뤄지는 자료구조.
 - 선입선출은 삽입과 삭제가 양방향에서 이뤄짐
 - 용어
   - rear: 큐에서 가장 끝 데이터를 가리키는 영역
   - front: 큐에서 가장 앞 데이터를 가리키는 영역
   - add: rear 부분에 새로운 데이터를 삽입하는 연산
   - poll: front 부분에 있는 데이터를 삭제하고 확인하는 연산
   - peek: 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산
 - 너비 우선 탐색(BFS)에서 자주 사용하므로 반드시 알아야함.

* 우선순위 큐
 - 값이 들어간 순서과 상관 없이 우선순위가 높은 데이터가 먼저 나옴
 - 큐 설정에 따라 front에 최댓값 또는 최솟값이 위치
 - 일반적으로 힙 heap을 이용해 구현하는데 트리 종류 중 하나



04. 정렬
 * 정렬 알고리즘의 정의
  - 버블: 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며
          정렬하는 방식
  - 선택: 대상에서 가장 크거나 작은 데이터를 찾아가
         선택을 반복하면서 정렬하는 방식
  - 삽입: 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아
         삽입하면서 정렬하는 방식
  - 퀵: pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
  - 병합: 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
  - 기수: 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식


04-1. 버블 정렬
 * 핵심 이론
  - 두 인접한 데이터의 크기를 비교해 정렬하는 방법.
    간단하게 구현할 순 있지만 시간 복잡도는 O(n^2)으로
    다른 정렬 알고리즘보다 속도가 느린 편.
    루프를 돌면서 인접한 데이터간의 swap 연산으로 정렬한다.
 * 정렬 과정
  ① 비교 연산이 필요한 루프 범위를 설정한다.
  ② 인접한 데이터 값을 비교한다.
  ③ swap 조건에 부합하면 swap 연산을 수행한다.
  ④ 루프 범위가 끝날 때까지 ②~③을 반복한다.
  ⑤ 정렬 영역을 설정합니다. 다음 루프를 실행할 때는 이 영역을 제외한다.
  ⑥ 비교 대상이 없을 때까지 ④~⑤를 반복한다.

04-2. 선택 정렬
 * 핵심 이론
  - 대상 데이터에서 최대/최소 데이터를 데이터가 나열된 순으로
    찾아가며 선택하는 방법.
    선택 정렬은 구현 방법이 복잡하고, 시간 복잡도도 O(n^2)으로
    효율적이지 않아 코딩테스트에서는 많이 사용하지 않는다.
  - 최솟값/최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와
    swap한다.
 * 정렬 과정
  ① 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
  ② 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
  ③ 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
  ④ 전체 데이터 크기만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다.

04-3. 삽입 정렬
 * 핵심 이론
  - 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에
    삽입시켜 정렬.
    평균 시간 복잡도는 O(n^2)으로 느린 편이지만 구현하기 쉬움
  - 선택 데이터를 현재 정렬된 범위 내에서 적절한 위치에 삽입하는 것
 * 정렬 과정
  ① 현재 index에 있는 데이터 값을 선택한다.
  ② 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
  ③ 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
  ④ 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
  ⑤ 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다.

04-4. 퀵 정렬
 * 핵심 이론
  - 기준값을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을
    반복해 정렬하는 알고리즘.
  - pivot을 중심으로 계속 데이터를 2개의 집합으로 나누면서 정렬하는 것

 * 정렬 과정
  ① 데이터를 분할하는 pivot을 설정한다（위 그림의 경우 가장 오른쪽 끝을 pivot으로 설정）.
  ② pivot을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
    ②-a start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면
         start를 오른쪽으로 1 칸 이동한다.
    ②-b end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면
         end를 왼쪽으로 1 칸 이동한다.
    ②-c start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고,
         end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면
         start, end가 가리키는 데이터를 swap하고
         start는 오른쪽, end는 왼쪽으로 1 칸씩 이동한다.
    ②-d start와 end가 만날 때까지 ②-a ~ ②-C를 반복한다.
    ②-e start와 end가 만나면 만난 지점에서 가리키는 데이터와
         pivot이 가리키는 데이터를 비교하여
         pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에,
         작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
  ③ 분리 집합에서 각각 다시 pivot을 선정한다.
  ④ 분리 집합이 1 개 이하가 될 때까지 과정 ①~③을 반복한다.


 ***퀵정렬***
출처: https://www.daleseo.com/sort-quick/

 1. 특징
- 파이썬의 list.sort()함수나 자바의 Arrays.sort()처럼 프로그래밍 언어 차원에서
기본적으로 지원되는 내장 정렬 함수는 대부분은 퀵 정렬을 기본으로 한다.
- 일반적으로 원소의 개수가 적어질수록 나쁜 중간값이 선택될 확률이 높아지기 때문에,
원소의 개수에 따라 퀵 정렬에 다른 정렬을 혼합해서 쓰는 경우가 많음.
- 병합 정렬과 퀵 정렬은 분할 정복과 재귀 알고리즘을 사용한다는 측면에서
유사해보이지만, 내부적으로 정렬을 하는 방식에서는 큰 차이가 있음.
- 병합 정렬은 항상 정 중앙을 기준으로 단순 분할 후 병합 시점에서 값의 비교 연산이
발생하는 반면, 퀵 정렬은 분할 시점부터 비교 연산이 일어나기 때문에 그 이후
병합에 들어가는 비용이 매우 적거나 구현 방법에 따라서 아예 병합을 하지 않을 수도 있음.

 2. 복잡도
- 성능은 pivot 값을 어떻게 선택하느냐에 따라 크게 달라짐.
이상적으로는 pivot 값을 기준으로 동일한 개수의 작은 값들과 큰 값들이
분할되어 병합 정렬과 마찬가지로 O(NlogN)의 시간 복잡도를 가짐.
- 하지만 pivot 값을 기준으로 분할했을 때 값들이 한편으로 크게 치우치게 되면,
퀵 정렬은 성능은 저하되게 되며, 최악의 경우 한편으로 모든 값들이 몰려
O(N^2)의 시간복잡도를 보이게 됨
- 상용 코드에서는 중앙값(median)에 가까운 pivot 값을 선택할 수 있는
섬세한 전략이 요구되며, 배열의 첫값과 중앙값 그리고 마지막값 중에
크기가 중간인 값을 사용하는 방법이 많이 사용됨.
- 퀵 정렬은 공간 복잡도는 구현 방법에 따라 달라질 수 있는데,
입력 배열이 차지하는 메모리만을 사용하는 in-place sorting 방식으로
구현을 할 경우, O(1)의 공간 복잡도를 가진 코드의 구현이 가능함

 3. 구현
- 위의 기본 컨셉 그대로를 코드로 구현 가능함.
먼저 리스트의 정 가운데 있는 값을 pivot 값으로 선택하고,
pivot 값보다 작은 값, 동일한 값, 큰 값을 담아둘 3개의 리스트를 생성함.
그리고 반복문을 통해 각 값을 pivot과 비교 후에 해당하는 리스트에 추가함.
마지막으로 재귀 호출의 결과를 다시 크기 순으로 합치면
정렬된 리스트를 얻을 수 있다.


04-5. 병합 정렬
 * 핵심 이론
   - 분할 정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며
     합치는 알고리즘임. 병합 정렬의 시간 복잡도 평균값은 O(nlogn)이다.
 * 2개의 그룹을 병합하는 과정
   - 투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합함.
     왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을
     결과 배열에 추가하고 포인터를 오른쪽으로 1칸 이동시킨다.


04-6. 기수 정렬
 * 핵심 이론
   - 값을 비교하지 않는 특이한 정렬. 값을 놓고 비교할 자릿수를 정한 다음
     해당 자릿수만 비교함. 시간복잡도는 O(kn)으로, k는 데이터의 자릿수를 말한다.
   - 10개의 큐를 이용하는데 각 큐는 자릿수를 대표한다.
   - 시간 복잡도가 가장 짧은 정렬임. 코딩테스트에서 정렬해야 하는 데이터의 갯수가
     너무 많으면 기수 정렬 알고리즘을 활용하라.


05. 탐색
 탐색은 주어진 데이터에서 자신이 원하는 데이터를 찾아내는 알고리즘.
 그래프를 자주 탐색하므로
 08-1 그래프의 표현 핵심 이론을 읽으면 도움이 된다.


05-1. 깊이 우선 탐색(DFS)
 그래프 완전 탐색 기법 중 하나임.
 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지
 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘임

 * 깊이 우선 탐색의 시간 복잡도
  - 기능: 그래프 완전 탐색
  - 특징: 1) 재귀 함수로 구현
         2) 스택 자료구조 이용
  - 시간 복잡도(노드 수: V, 에지 수: E): O(V+E)

 실제 구현 시 재귀함수를 이용하므로 스택 오버플로에 유의해야 함.
 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있음.

 * 핵심 이론
  - DFS는 한번 방문한 노드를 다시 방문하면 안 되므로
    노드 방문 여부를 체크할 배열이 필요하며,
    그래프를 인접 리스트로 표현할 것이다.
    탐색 방식은 후입선출 특성을 가지므로 스택을 사용할 것이다.
    (실제로 스택보다는 스택 성질을 갖는 재귀 함수로 많이 구현함.)

